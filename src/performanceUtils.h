/*
 * Copyright 2012, Michael Vyverman <michael.vyverman@ugent.be>
 *
 * This file is part of ALFALFA.
 *
 * ALFALFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * ALFALFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ALFALFA.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef PERFORMANCEUTILS_H
#define	PERFORMANCEUTILS_H

#include <bitset>
#include <vector>
#include <string.h>
#include <fstream>

#include "optionparser.h"
#include "options.h"

//#define CHECK_BIT(var,pos) ((var) & (1<<(pos)))
//#define SET_BIT(var,pos) ((var) | (1<<(pos)))

enum checkCommand_t {ORACLE, SUMMARY, COMPARE, WGSIM};

struct samCheckOptions_t {
    samCheckOptions_t(){ initOptions(); }
    void initOptions(){
        subcommand = SUMMARY;
        outputFile = "";
        oracleSam = "";
        refString = "";
        paired = false;
        querySam = "";
        qtag = "NM";
        otag = "XE";
        numReads=0;
        print = false;
    }
    checkCommand_t subcommand;
    std::string outputFile;
    std::string oracleSam;
    std::string refString;
    bool paired;
    bool print;
    std::string querySam;
    std::vector<std::string> compareFiles;
    std::vector<int> qualityValues;
    std::vector<int> correctRange;
    std::string qtag;
    std::string otag;
    long numReads;
    //other options to change or reduce the output
};

struct samRecord_t {
    samRecord_t(): qname(""), flag(0), rname(""), pos(0), mapq(0), rnext(""), pnext(0), edit(0){}
    samRecord_t(const samRecord_t& o): qname(o.qname), flag(o.flag.to_ulong()), rname(o.rname), 
    pos(o.pos), mapq(o.mapq), rnext(o.rnext), pnext(o.pnext), edit(o.edit) {}
    std::string qname;
    std::bitset<11> flag;
    std::string rname;
    long pos;
    int mapq;
    std::string rnext;
    long pnext;
    int edit;
};

enum evaluateOptionIndex {
    ARG_NOT_FOUND,
    ARG_INPUT_SAM,
    ARG_OUTPUT_EVAL,
    ARG_QUALITY,
    ARG_PRINT,
    ARG_HELP_EVAL,
    ARG_READS,
    ARG_PAIRED,
    ARG_REFERENCE_EVAL,
    ARG_WINDOW,
    ARG_INPUT_EDIT,
    ARG_REFERENCE_SAM,
    ARG_REFERENCE_EDIT
};

const option::Descriptor evaluateUsage[] = 
{
    {ARG_NOT_FOUND,       0, "",  "",              Arg::None,          "Usage: alfalfa evaluate <subcommand> [option...]\nevaluate is used for evaluating the accuracy of simulated reads and summarizing statistics from the SAM-formatted alignments reported by a read mapper.\nSubcommand should be summary, sam or wgsim\n\nsubcommands:\n"},
    {ARG_NOT_FOUND,       0, "",  "",              Arg::None,          "evaluate summary \treports statistics about the number of mapped reads for which the actual mapping locations are unknown"},
    {ARG_NOT_FOUND,       0, "",  "",              Arg::None,          "evaluate sam \tis used to evaluate the accuracy for sequencing reads generated by the Mason simulator and other read simulators that produce a reference SAM file containing alignments for the simulated reads"},
    {ARG_NOT_FOUND,       0, "",  "",              Arg::None,          "evaluate wgsim \tis used to evaluate the accuracy for reads simulated by wgsim"},
    {ARG_NOT_FOUND,       0, "",  "",              Arg::None,          "\ncall alfalfa evaluate <subcommand> -h/--help for more detailed information on the specific subcommands\n"},
    {0,0,0,0,0,0}
};

const option::Descriptor summaryUsage[] = 
{
    {ARG_NOT_FOUND,     0, "",  "",              Arg::None,          0},
    {ARG_NOT_FOUND,     0, "",  "",              Arg::None,          "\nUsage: alfalfa evaluate summary [option...]\nevaluate summary reports statistics about the number of mapped reads for which the actual mapping locations are unknown\n\noptions "},
    {ARG_INPUT_SAM,     0, "i", "input-sam",     Arg::Required,      "-i/--input-sam \t(file).\vSpecifies the location of a SAM file that contains the read mapping alignments that need to be evaluated."},
    {ARG_OUTPUT_EVAL,   0, "o", "output",        Arg::Required,      "-o/--output \t(file, standard output).\vSpecifies the location of the file that will contain the generated output."},
    {ARG_QUALITY,       0, "q", "quality",       Arg::Required,      "-q/--quality \t(comma-separated list of ints between 0 and 255, 0).\vThe values in the list represent quality thresholds. For each specified quality threshold, output is produced that reports only on the subset of alignments with quality value greater than or equal to the threshold."},
    {ARG_READS,         0, "",  "reads",         Arg::Required,      "--reads \t(int).\vSpecifies the number of reads given as input to the read mapper that produced the input SAM file (option --input-sam). This number can be different from the number of reads contained in the input SAM file (option --input-sam) if for example unmapped reads are not reported."},
    {ARG_PAIRED,        0, "",  "paired",        Arg::None,          "--paired \t.\vBy default, the input SAM file (option --input-sam) is supposed to contain single-end reads. If the --paired option is set, it is supposed to contain paired-end reads. The summary for paired-end reads contains information on the number of reads mapped as paired and unpaired, as indicated by the flag field of the SAM format."},
    {ARG_PRINT,         0, "p", "print",         Arg::None,          "-p/--print \t.\vThis option triggers the generated output to contain a list of all reads from the input SAM file followed by a binary value. Zero indicates that the read is either unmapped or incorrectly mapped and one indicates that the read was mapped (summary subcommand) or mapped correctly (other subcommands)."},
    {ARG_HELP_EVAL,     0, "h", "help",          Arg::None,          "-h/--help \t.\vPrints to standard error the version number, usage description and an overview of the options that can be used to customize the software package."},
    {0,0,0,0,0,0}
};

const option::Descriptor samUsage[] = 
{
    {ARG_NOT_FOUND,     0, "",  "",              Arg::None,          0},
    {ARG_NOT_FOUND,     0, "",  "",              Arg::None,          "\nUsage: alfalfa evaluate sam [option...]\nevaluate sam is used to evaluate the accuracy for sequencing reads generated by the Mason simulator and other read simulators that produce a reference SAM file containing alignments for the simulated reads\n\noptions "},
    {ARG_INPUT_SAM,     0, "i", "input-sam",     Arg::Required,      "-i/--input-sam \t(file).\vSpecifies the location of a SAM file that contains the read mapping alignments that need to be evaluated."},
    {ARG_OUTPUT_EVAL,   0, "o", "output",        Arg::Required,      "-o/--output \t(file, standard output).\vSpecifies the location of the file that will contain the generated output."},
    {ARG_REFERENCE_EVAL,0, "r", "reference",     Arg::Required,      "-r/--reference \t(file).\vSpecifies the location of a file that contains the reference genome in multi-fasta format."},
    {ARG_WINDOW,        0, "w", "window",        Arg::Required,      "-w/--window \t(comma-separated list of ints, 50).\vThe values in the list represent window sizes around the position in the reference genome from which the simulated read was extracted. An alignment is considered to be mapped correctly if it is mapped within a given window around the simulated position. Output is generated for each individual value."},
    {ARG_QUALITY,       0, "q", "quality",       Arg::Required,      "-q/--quality \t(comma-separated list of ints between 0 and 255, 0).\vThe values in the list represent quality thresholds. For each specified quality threshold, output is produced that reports only on the subset of alignments with quality value greater than or equal to the threshold."},
    {ARG_INPUT_EDIT,    0, "",  "input-edit",    Arg::Required,      "--input-edit \t(string, NM).\vSpecifies the field of the SAM format that contains the edit distance of the alignments in the input SAM file (option --i). If no such field exists, the edit distance is computed from the CIGAR string, the read sequence and the reference genome. An alignment that is not mapped within a certain window around the simulated position (option --w) is considered plausibly mapped if its edit distance is less than the edit distance of the alignment taken from the reference SAM file (option --reference-sam)."},
    {ARG_REFERENCE_SAM, 0, "",  "reference-sam", Arg::Required,      "--reference-sam \t(file).\vSpecifies the location of a reference SAM file containing alignments of the simulated reads as generated by the Mason simulator. Alignments contained in this file should be sorted by read name, which is easily done using SAMtools."},
    {ARG_REFERENCE_EDIT,0, "",  "reference-edit",Arg::Required,      "--reference-edit \t(string, XE).\vSpecifies the field of the SAM format that contains the edit distance of the alignments in the reference SAM file (option -reference-sam). The default value is set to XE because this is the field used by the Mason simulator."},
    {ARG_PRINT,         0, "p", "print",         Arg::None,          "-p/--print \t.\vThis option triggers the generated output to contain a list of all reads from the input SAM file followed by a binary value. Zero indicates that the read is either unmapped or incorrectly mapped and one indicates that the read was mapped (summary subcommand) or mapped correctly (other subcommands)."},
    {ARG_HELP_EVAL,     0, "h", "help",          Arg::None,          "-h/--help \t.\vPrints to standard error the version number, usage description and an overview of the options that can be used to customize the software package."},
    {0,0,0,0,0,0}
};

const option::Descriptor wgsimUsage[] = 
{
    {ARG_NOT_FOUND,     0, "",  "",              Arg::None,          0},
    {ARG_NOT_FOUND,     0, "",  "",              Arg::None,          "\nUsage: alfalfa evaluate wgsim [option...]\nevaluate wgsim is used to evaluate the accuracy for reads simulated by wgsim\n\noptions "},
    {ARG_INPUT_SAM,     0, "i", "input-sam",     Arg::Required,      "-i/--input-sam \t(file).\vSpecifies the location of a SAM file that contains the read mapping alignments that need to be evaluated."},
    {ARG_OUTPUT_EVAL,   0, "o", "output",        Arg::Required,      "-o/--output \t(file, standard output).\vSpecifies the location of the file that will contain the generated output."},
    {ARG_REFERENCE_EVAL,0, "r", "reference",     Arg::Required,      "-r/--reference \t(file).\vSpecifies the location of a file that contains the reference genome in multi-fasta format."},
    {ARG_WINDOW,        0, "w", "window",        Arg::Required,      "-w/--window \t(comma-separated list of ints, 50).\vThe values in the list represent window sizes around the position in the reference genome from which the simulated read was extracted. An alignment is considered to be mapped correctly if it is mapped within a given window around the simulated position. Output is generated for each individual value."},
    {ARG_QUALITY,       0, "q", "quality",       Arg::Required,      "-q/--quality \t(comma-separated list of ints between 0 and 255, 0).\vThe values in the list represent quality thresholds. For each specified quality threshold, output is produced that reports only on the subset of alignments with quality value greater than or equal to the threshold."},
    {ARG_INPUT_EDIT,    0, "",  "input-edit",    Arg::Required,      "--input-edit \t(string, NM).\vSpecifies the field of the SAM format that contains the edit distance of the alignments in the input SAM file (option --i). If no such field exists, the edit distance is computed from the CIGAR string, the read sequence and the reference genome. An alignment that is not mapped within a certain window around the simulated position (option --w) is considered plausibly mapped if its edit distance is less than the edit distance of the alignment taken from the reference SAM file (option --reference-sam)."},
    {ARG_PRINT,         0, "p", "print",         Arg::None,          "-p/--print \t.\vThis option triggers the generated output to contain a list of all reads from the input SAM file followed by a binary value. Zero indicates that the read is either unmapped or incorrectly mapped and one indicates that the read was mapped (summary subcommand) or mapped correctly (other subcommands)."},
    {ARG_HELP_EVAL,     0, "h", "help",          Arg::None,          "-h/--help \t.\vPrints to standard error the version number, usage description and an overview of the options that can be used to customize the software package."},
    {0,0,0,0,0,0}
};

//find edit distance:
//read ref string, make out coordinates.
//NEW OPTIONS
//ref string, read it, dp matrix, create it.
//boundaries: query full, ref begin and end: count from cigar (take into account clipping)
//band: oracle --> NM = editDist
//nothing free

struct oracleLine_t {
    oracleLine_t(): alignmentCnt(0),alnGood(0),alnOk(0),alnBad(0),readGood(0),readOk(0),readBad(0), tempReadResult(0){}
    long alignmentCnt;
    long alnGood;
    long alnOk;
    long alnBad;
    long readGood;
    long readOk;
    long readBad;
    int tempReadResult;
    void init(){
        alignmentCnt=alnGood=alnOk=alnBad=readGood=readOk=readBad=0L;
        tempReadResult=0;
    }
    void addAlignment(int score);
    void finishRead();
    std::string printLine(long readcnt);
};

struct summaryLine_t {
    summaryLine_t(): readMapped(0),readPaired(0),readPairedCorrect(0),
    secondAln(0),mappedPairedCorrect(0), mappedPaired(0),mappedAln(0), alignmentCnt(0), 
    tempReadResult(0), tempAlnCount(0) {for(int i=0; i < 102; i++){alnPerRead[i]=0;}}
    long readMapped;
    long readPaired;
    long readPairedCorrect;
    long secondAln;
    long mappedPairedCorrect;
    long mappedPaired;
    long mappedAln;
    long alignmentCnt;
    int alnPerRead[102];//0-100 + 1 meaning 100+
    int tempReadResult;
    int tempAlnCount;
    
    void addAlignment(int flag, bool mateFound);
    void finishRead();
    std::string printLine(long readcnt, bool paired);
};

void checkOracle(samCheckOptions_t & opt);

void checkWgsim(samCheckOptions_t & opt);

void checkSummary(samCheckOptions_t & opt);

void processCheckParameters(int argc, char* argv[], samCheckOptions_t& opt);

#endif	/* PERFORMANCEUTILS_H */

